#include <sl.h>


int main() {
    printf("LONG STRING TEST: \n");
    
    char *long_str1 = "Макрос va_arg() раскрывается в выражение, которое имеет тип и значение следующего аргумента в вызове. Аргумент ap — это va_list ap, инициализированный va_start(). Каждый вызов va_arg() изменяет ap так, что следующий вызов возвращает следующий аргумент. Аргумент type — это имя типа, указанное так, что тип указателя на объект, который имеет указанный тип, можно получить просто добавив * в type. Первый вызов макроса va_arg() после va_start() вернёт аргумент после last. Последующие вызовы вернут значения оставшихся аргументов. Если аргументы закончились, или если type не совместим с типом настоящего следующего аргумента (преобразование происходит согласно преобразованию аргументов по умолчанию), может произойти любая ошибка. Если ap передан в функцию, которая использует va_arg(ap,type), то значение ap не определено после возврата из функции. ";
    char *long_str2 = "Макрос va_copy() копирует (ранее инициализированный) список с переменным количеством аргументов src в dest. Его действие такое же, как если бы va_start() применили к dest с тем же аргументом last, после чего было бы совершено такое же количество вызовов va_arg(), которое имеется в текущем состоянии src. Очевидной реализацией было бы создать переменную с типом va_list, указывающую на стековый фрейм функции с переменным количеством аргументов. В этом случае (безусловно, наиболее распространенном) кажется, что достаточно присвоения va_list aq = ap; К сожалению, есть системы, в которых это массив указателей (длиной 1), и нужно делать va_list aq; *aq = *ap; Наконец, в системах, где аргументы передаются через регистры, в va_start() может потребоваться выделить память, сохранить там аргументы, а также индекс следующего элемента для того, чтобы va_arg() мог обойти список. Также va_end() может освобождать выделенную память. Чтобы всё это учесть в C99 добавлен макрос va_copy(), который позволяет показанное выше назначение заменить на";
    char *long_str3 = "Эти функции позволяют программам, созданным на Си, вызывать удалённые процедуры на других машинах в сети. Сначала, клиент вызывает процедуру путём отправки пакета с данными на сервер. После принятия пакета сервер вызывает функцию распределения (dispatch) для выполнения запрошенной службы и отсылает ответ обратно. Последним действием результат выполнения процедуры возвращается клиенту.";
    char *long_str4 = "Эта функция создаёт клиента RPC для удалённой программы prognum версии versnum; для передачи клиент использует протокол UDP/IP. Удалённая программа расположена по интернет-адресу *addr. Если addr->sin_port равно 0, тогда ему назначается реальный порт, который прослушивается удалённой программой (эта информация запрашивается у удалённой службы portmap). Параметр sockp — сокет; если его значение равно RPC_ANYSOCK, тогда эта функция открывает новый сокет и изменяет sockp. Протокол UDP повторяет отправку сообщения через интервал, указанный в параметре wait, пока не будет получен ответ или не истечёт время ожидания. Полное время ожидания вызова определяется clnt_call(). ";

    Logger_t logger = {
        "LST",
        "[",
        "]"
    };

    logMsg(logger, SL_LVL_INFO, long_str1, NULL);
    logMsg(logger, SL_LVL_INFO, long_str2, NULL);
    logMsg(logger, SL_LVL_INFO, long_str3, NULL);
    logMsg(logger, SL_LVL_INFO, long_str4, NULL);
}